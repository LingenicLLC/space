/* Space Language Runtime
 * Generated by Space.Compiler.CGen.Runtime
 *
 * This file is AUTO-GENERATED from verified F* definitions.
 * Do not edit manually.
 *
 * Source modules:
 *   Space.Types      - Cell, discipline, identifiers
 *   Space.Stack      - Stack operations
 *   Space.Arithmetic - Wrapping arithmetic
 *   Space.Bitwise    - Bitwise operations
 *   Space.Comparison - Comparisons
 *   Space.Memory     - Memory allocation
 *   Space.Bytes      - Byte array operations
 *   Space.Universe   - Isolated memory regions
 *   Space.Borrow     - Cross-universe pointer access
 *   Space.Warp       - Structured traversal
 *   Space.Text.*     - Text handling with Unicode
 */

#ifndef SPACE_RUNTIME_H
#define SPACE_RUNTIME_H

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

#include "space_ucd_full.h"

/*
 * Configuration
 */
#ifndef SPACE_STACK_SIZE
#define SPACE_STACK_SIZE 65536
#endif

#ifndef SPACE_MEMORY_SIZE
#define SPACE_MEMORY_SIZE (4 * 1024 * 1024)
#endif

#ifndef SPACE_MAX_TEXTS
#define SPACE_MAX_TEXTS 1024
#endif

/*
 * Stack - mirrors Space.Stack
 * Invariant: sp points to top element, -1 when empty
 */
static uint64_t space_stack[SPACE_STACK_SIZE];
static int space_sp = -1;

#define PUSH(v) (space_stack[++space_sp] = (v))
#define POP()   (space_stack[space_sp--])
#define TOP()   (space_stack[space_sp])
#define NOS()   (space_stack[space_sp - 1])

/*
 * Memory - mirrors Space.Memory
 * Linear allocator with tracking for bytes-length
 */
static uint8_t space_memory[SPACE_MEMORY_SIZE];
static size_t space_mem_ptr = 0;

typedef struct {
    void *ptr;
    size_t len;
} space_alloc_entry;

static space_alloc_entry space_allocs[SPACE_MAX_TEXTS];
static size_t space_alloc_count = 0;

static inline void* space_alloc(size_t n) {
    if (space_mem_ptr + n > SPACE_MEMORY_SIZE) return NULL;
    void *p = &space_memory[space_mem_ptr];
    space_allocs[space_alloc_count].ptr = p;
    space_allocs[space_alloc_count].len = n;
    space_alloc_count++;
    space_mem_ptr += n;
    return p;
}

static inline size_t space_bytes_len(void *p) {
    for (size_t i = 0; i < space_alloc_count; i++) {
        if (space_allocs[i].ptr == p) return space_allocs[i].len;
    }
    return 0;
}

static inline void space_bytes_copy(void *dst, void *src, size_t n) {
    memcpy(dst, src, n);
}

/*
 * Universe - mirrors Space.Universe
 * Isolated memory region with its own stack and discipline
 */

typedef enum {
    DISC_UNRESTRICTED = 0,  /* Can copy and drop freely */
    DISC_AFFINE = 1,        /* Cannot copy, can drop */
    DISC_LINEAR = 2         /* Cannot copy, cannot drop - must consume exactly once */
} space_discipline;

typedef enum {
    UNIVERSE_LIVE = 0,
    UNIVERSE_DESTROYED = 1
} space_universe_state;

#ifndef SPACE_MAX_UNIVERSES
#define SPACE_MAX_UNIVERSES 64
#endif

#ifndef SPACE_UNIVERSE_STACK_SIZE
#define SPACE_UNIVERSE_STACK_SIZE 1024
#endif

#ifndef SPACE_UNIVERSE_MEM_SIZE
#define SPACE_UNIVERSE_MEM_SIZE (64 * 1024)
#endif

typedef struct {
    uint32_t id;
    char name[64];
    space_discipline discipline;
    space_universe_state state;
    uint64_t stack[SPACE_UNIVERSE_STACK_SIZE];
    int sp;
    uint8_t memory[SPACE_UNIVERSE_MEM_SIZE];
    size_t mem_ptr;
    uint32_t capacity;
} space_universe;

static space_universe space_universes[SPACE_MAX_UNIVERSES];
static uint32_t space_universe_count = 0;
static uint32_t space_current_universe = 0;  /* 0 = global/parent */

static inline uint32_t space_create_universe(const char *name, uint32_t capacity, space_discipline disc) {
    if (space_universe_count >= SPACE_MAX_UNIVERSES) return 0;
    uint32_t id = ++space_universe_count;
    space_universe *u = &space_universes[id];
    u->id = id;
    strncpy(u->name, name, 63);
    u->name[63] = '\0';
    u->discipline = disc;
    u->state = UNIVERSE_LIVE;
    u->sp = -1;
    u->mem_ptr = 0;
    u->capacity = capacity;
    return id;
}

static inline int space_universe_is_live(uint32_t id) {
    if (id == 0 || id > space_universe_count) return 0;
    return space_universes[id].state == UNIVERSE_LIVE;
}

static inline int space_universe_stack_empty(uint32_t id) {
    if (id == 0 || id > space_universe_count) return 1;
    return space_universes[id].sp < 0;
}

static inline int space_universe_should_destruct(uint32_t id) {
    if (id == 0 || id > space_universe_count) return 0;
    space_universe *u = &space_universes[id];
    return u->discipline == DISC_LINEAR && u->sp < 0 && u->state == UNIVERSE_LIVE;
}

static inline void space_universe_destroy(uint32_t id) {
    if (id == 0 || id > space_universe_count) return;
    space_universes[id].state = UNIVERSE_DESTROYED;
}

static inline int space_universe_push(uint32_t id, uint64_t v) {
    if (!space_universe_is_live(id)) return 0;
    space_universe *u = &space_universes[id];
    if (u->sp >= (int)u->capacity - 1) return 0;
    u->stack[++u->sp] = v;
    return 1;
}

static inline int space_universe_pop(uint32_t id, uint64_t *v) {
    if (!space_universe_is_live(id)) return 0;
    space_universe *u = &space_universes[id];
    if (u->sp < 0) return 0;
    *v = u->stack[u->sp--];
    return 1;
}

static inline void* space_universe_alloc(uint32_t id, size_t n) {
    if (!space_universe_is_live(id)) return NULL;
    space_universe *u = &space_universes[id];
    if (u->mem_ptr + n > SPACE_UNIVERSE_MEM_SIZE) return NULL;
    void *p = &u->memory[u->mem_ptr];
    u->mem_ptr += n;
    return p;
}

/*
 * Borrowing - mirrors Space.Borrow
 * Borrowed pointers for cross-universe access
 */

#ifndef SPACE_MAX_BORROWS
#define SPACE_MAX_BORROWS 256
#endif

typedef struct {
    uint64_t address;
    uint32_t source_id;
    int is_active;
} space_borrowed;

static space_borrowed space_borrows[SPACE_MAX_BORROWS];
static size_t space_borrow_count = 0;

static inline size_t space_borrow_pointer(uint32_t src_id, uint64_t addr) {
    if (space_borrow_count >= SPACE_MAX_BORROWS) return SIZE_MAX;
    size_t idx = space_borrow_count++;
    space_borrows[idx].address = addr;
    space_borrows[idx].source_id = src_id;
    space_borrows[idx].is_active = 1;
    return idx;
}

static inline int space_borrow_active(size_t idx) {
    if (idx >= space_borrow_count) return 0;
    return space_borrows[idx].is_active;
}

static inline void space_drop_borrow(size_t idx) {
    if (idx < space_borrow_count) {
        space_borrows[idx].is_active = 0;
    }
}

static inline uint64_t space_fetch_borrowed(size_t idx) {
    if (idx >= space_borrow_count || !space_borrows[idx].is_active) return 0;
    uint64_t *p = (uint64_t*)(uintptr_t)space_borrows[idx].address;
    return *p;
}

static inline void space_store_borrowed(size_t idx, uint64_t v) {
    if (idx >= space_borrow_count || !space_borrows[idx].is_active) return;
    uint64_t *p = (uint64_t*)(uintptr_t)space_borrows[idx].address;
    *p = v;
}

static inline int space_has_borrows_from(uint32_t src_id) {
    for (size_t i = 0; i < space_borrow_count; i++) {
        if (space_borrows[i].source_id == src_id && space_borrows[i].is_active) {
            return 1;
        }
    }
    return 0;
}

/*
 * Warps - mirrors Space.Warp
 * Structured traversal of universes
 */

#ifndef SPACE_MAX_WARPS
#define SPACE_MAX_WARPS 32
#endif

#ifndef SPACE_WARP_SAVE_DEPTH
#define SPACE_WARP_SAVE_DEPTH 16
#endif

typedef struct {
    uint32_t id;
    char name[64];
    uint32_t target_id;
    uint64_t position;
    uint64_t saved_positions[SPACE_WARP_SAVE_DEPTH];
    int save_count;
    int readonly;
    int active;
} space_warp;

static space_warp space_warps[SPACE_MAX_WARPS];
static uint32_t space_warp_count = 0;

static inline uint32_t space_warp_into(const char *name, uint32_t target_id, uint64_t pos, int readonly) {
    if (space_warp_count >= SPACE_MAX_WARPS) return 0;
    uint32_t id = ++space_warp_count;
    space_warp *w = &space_warps[id];
    w->id = id;
    strncpy(w->name, name, 63);
    w->name[63] = '\0';
    w->target_id = target_id;
    w->position = pos;
    w->save_count = 0;
    w->readonly = readonly;
    w->active = 1;
    return id;
}

static inline void space_end_warp(uint32_t id) {
    if (id == 0 || id > space_warp_count) return;
    space_warps[id].active = 0;
}

static inline int space_warp_active(uint32_t id) {
    if (id == 0 || id > space_warp_count) return 0;
    return space_warps[id].active;
}

static inline uint64_t space_warp_position(uint32_t id) {
    if (id == 0 || id > space_warp_count) return 0;
    return space_warps[id].position;
}

static inline void space_warp_set_position(uint32_t id, uint64_t pos) {
    if (id == 0 || id > space_warp_count) return;
    space_warps[id].position = pos;
}

static inline void space_warp_advance(uint32_t id, uint64_t offset) {
    if (id == 0 || id > space_warp_count) return;
    space_warps[id].position += offset;
}

static inline uint64_t space_warp_fetch(uint32_t id) {
    if (id == 0 || id > space_warp_count || !space_warps[id].active) return 0;
    uint64_t *p = (uint64_t*)(uintptr_t)space_warps[id].position;
    return *p;
}

static inline void space_warp_store(uint32_t id, uint64_t v) {
    if (id == 0 || id > space_warp_count || !space_warps[id].active) return;
    if (space_warps[id].readonly) return;
    uint64_t *p = (uint64_t*)(uintptr_t)space_warps[id].position;
    *p = v;
}

static inline void space_warp_save(uint32_t id) {
    if (id == 0 || id > space_warp_count) return;
    space_warp *w = &space_warps[id];
    if (w->save_count < SPACE_WARP_SAVE_DEPTH) {
        w->saved_positions[w->save_count++] = w->position;
    }
}

static inline int space_warp_restore(uint32_t id, uint64_t pos) {
    if (id == 0 || id > space_warp_count) return 0;
    space_warp *w = &space_warps[id];
    for (int i = 0; i < w->save_count; i++) {
        if (w->saved_positions[i] == pos) {
            w->position = pos;
            return 1;
        }
    }
    return 0;
}

static inline int space_warp_is_null(uint32_t id) {
    if (id == 0 || id > space_warp_count) return 1;
    return space_warps[id].position == 0;
}

static inline int space_has_warps_to(uint32_t target_id) {
    for (uint32_t i = 1; i <= space_warp_count; i++) {
        if (space_warps[i].target_id == target_id && space_warps[i].active) {
            return 1;
        }
    }
    return 0;
}

/*
 * Text - mirrors Space.Text.Types
 * Handle-based text storage with UTF-8 data
 */
typedef struct {
    uint8_t *data;
    size_t byte_len;
    size_t grapheme_count;
} space_text;

static space_text space_texts[SPACE_MAX_TEXTS];
static size_t space_text_count = 0;

static inline size_t space_create_text(const uint8_t *data, size_t len) {
    size_t handle = space_text_count++;
    space_texts[handle].data = (uint8_t*)space_alloc(len);
    memcpy(space_texts[handle].data, data, len);
    space_texts[handle].byte_len = len;
    space_texts[handle].grapheme_count = len;  /* Updated by grapheme counter */
    return handle;
}

static inline size_t space_text_byte_length(size_t handle) {
    return space_texts[handle].byte_len;
}

static inline size_t space_text_grapheme_count(size_t handle) {
    return space_texts[handle].grapheme_count;
}

static inline const uint8_t* space_text_data(size_t handle) {
    return space_texts[handle].data;
}

/*
 * I/O Primitives - mirrors Space.System
 */
static inline void space_emit(uint64_t c) {
    putchar((int)c);
}

static inline uint64_t space_key(void) {
    return (uint64_t)getchar();
}

static inline void space_emit_text(size_t handle) {
    fwrite(space_texts[handle].data, 1, space_texts[handle].byte_len, stdout);
}

/*
 * Stack Primitives - mirrors Space.Stack
 * Each operation preserves stack invariants
 */

/* dup ( a -- a a ) */
static inline void prim_dup(void) {
    uint64_t a = TOP();
    PUSH(a);
}

/* drop ( a -- ) */
static inline void prim_drop(void) {
    space_sp--;
}

/* swap ( a b -- b a ) */
static inline void prim_swap(void) {
    uint64_t b = POP();
    uint64_t a = POP();
    PUSH(b);
    PUSH(a);
}

/* over ( a b -- a b a ) */
static inline void prim_over(void) {
    uint64_t a = NOS();
    PUSH(a);
}

/* rot ( a b c -- b c a ) */
static inline void prim_rot(void) {
    uint64_t c = POP();
    uint64_t b = POP();
    uint64_t a = POP();
    PUSH(b);
    PUSH(c);
    PUSH(a);
}

/* nip ( a b -- b ) */
static inline void prim_nip(void) {
    uint64_t b = POP();
    space_sp--;
    PUSH(b);
}

/* tuck ( a b -- b a b ) */
static inline void prim_tuck(void) {
    uint64_t b = POP();
    uint64_t a = POP();
    PUSH(b);
    PUSH(a);
    PUSH(b);
}

/*
 * Arithmetic Primitives - mirrors Space.Arithmetic
 * All operations use wrapping semantics (mod 2^64)
 */

/* add ( a b -- a+b ) */
static inline void prim_add(void) {
    uint64_t b = POP();
    space_stack[space_sp] += b;
}

/* sub ( a b -- a-b ) */
static inline void prim_sub(void) {
    uint64_t b = POP();
    space_stack[space_sp] -= b;
}

/* mul ( a b -- a*b ) */
static inline void prim_mul(void) {
    uint64_t b = POP();
    space_stack[space_sp] *= b;
}

/* div-u ( a b -- a/b ) unsigned division */
static inline void prim_div_u(void) {
    uint64_t b = POP();
    space_stack[space_sp] /= b;
}

/* div-s ( a b -- a/b ) signed division */
static inline void prim_div_s(void) {
    int64_t b = (int64_t)POP();
    space_stack[space_sp] = (uint64_t)((int64_t)space_stack[space_sp] / b);
}

/* mod ( a b -- a%b ) */
static inline void prim_mod(void) {
    uint64_t b = POP();
    space_stack[space_sp] %= b;
}

/* neg ( a -- -a ) two's complement negation */
static inline void prim_neg(void) {
    space_stack[space_sp] = (uint64_t)(-(int64_t)space_stack[space_sp]);
}

/* min ( a b -- min(a,b) ) unsigned */
static inline void prim_min(void) {
    uint64_t b = POP();
    if (b < TOP()) space_stack[space_sp] = b;
}

/* max ( a b -- max(a,b) ) unsigned */
static inline void prim_max(void) {
    uint64_t b = POP();
    if (b > TOP()) space_stack[space_sp] = b;
}

/*
 * Bitwise Primitives - mirrors Space.Bitwise
 */

/* and ( a b -- a&b ) */
static inline void prim_and(void) {
    uint64_t b = POP();
    space_stack[space_sp] &= b;
}

/* or ( a b -- a|b ) */
static inline void prim_or(void) {
    uint64_t b = POP();
    space_stack[space_sp] |= b;
}

/* xor ( a b -- a^b ) */
static inline void prim_xor(void) {
    uint64_t b = POP();
    space_stack[space_sp] ^= b;
}

/* not ( a -- ~a ) bitwise complement */
static inline void prim_not(void) {
    space_stack[space_sp] = ~space_stack[space_sp];
}

/* shl ( a n -- a<<n ) */
static inline void prim_shl(void) {
    uint64_t n = POP();
    space_stack[space_sp] <<= n;
}

/* shr ( a n -- a>>n ) logical shift right */
static inline void prim_shr(void) {
    uint64_t n = POP();
    space_stack[space_sp] >>= n;
}

/*
 * Comparison Primitives - mirrors Space.Comparison
 * Return 1 for true, 0 for false
 */

/* eq ( a b -- a==b ) */
static inline void prim_eq(void) {
    uint64_t b = POP();
    space_stack[space_sp] = (space_stack[space_sp] == b) ? 1 : 0;
}

/* neq ( a b -- a!=b ) */
static inline void prim_neq(void) {
    uint64_t b = POP();
    space_stack[space_sp] = (space_stack[space_sp] != b) ? 1 : 0;
}

/* lt-s ( a b -- a<b ) signed */
static inline void prim_lt_s(void) {
    int64_t b = (int64_t)POP();
    space_stack[space_sp] = ((int64_t)space_stack[space_sp] < b) ? 1 : 0;
}

/* gt-s ( a b -- a>b ) signed */
static inline void prim_gt_s(void) {
    int64_t b = (int64_t)POP();
    space_stack[space_sp] = ((int64_t)space_stack[space_sp] > b) ? 1 : 0;
}

/* lt-u ( a b -- a<b ) unsigned */
static inline void prim_lt_u(void) {
    uint64_t b = POP();
    space_stack[space_sp] = (space_stack[space_sp] < b) ? 1 : 0;
}

/* gt-u ( a b -- a>b ) unsigned */
static inline void prim_gt_u(void) {
    uint64_t b = POP();
    space_stack[space_sp] = (space_stack[space_sp] > b) ? 1 : 0;
}

/*
 * Memory Primitives - mirrors Space.Memory, Space.Bytes
 */

/* alloc ( n -- ptr ) allocate n bytes */
static inline void prim_alloc(void) {
    size_t n = (size_t)POP();
    PUSH((uint64_t)(uintptr_t)space_alloc(n));
}

/* fetch ( ptr -- value ) fetch 64-bit cell */
static inline void prim_fetch(void) {
    uint64_t *p = (uint64_t*)(uintptr_t)TOP();
    space_stack[space_sp] = *p;
}

/* store ( value ptr -- ) store 64-bit cell */
static inline void prim_store(void) {
    uint64_t *p = (uint64_t*)(uintptr_t)POP();
    uint64_t v = POP();
    *p = v;
}

/* bytes-fetch ( ptr offset -- byte ) */
static inline void prim_bytes_fetch(void) {
    size_t off = (size_t)POP();
    uint8_t *p = (uint8_t*)(uintptr_t)TOP();
    space_stack[space_sp] = p[off];
}

/* bytes-store ( byte ptr offset -- ) */
static inline void prim_bytes_store(void) {
    size_t off = (size_t)POP();
    uint8_t *p = (uint8_t*)(uintptr_t)POP();
    uint8_t v = (uint8_t)POP();
    p[off] = v;
}

/*
 * Universe Primitives - create/destroy/push/pop
 */

/* create-universe ( capacity discipline -- id ) */
static inline void prim_create_universe(void) {
    space_discipline disc = (space_discipline)POP();
    uint32_t cap = (uint32_t)POP();
    uint32_t id = space_create_universe("anon", cap, disc);
    PUSH(id);
}

/* end-universe ( id -- ) check for self-destruct */
static inline void prim_end_universe(void) {
    uint32_t id = (uint32_t)POP();
    if (space_universe_should_destruct(id)) {
        space_universe_destroy(id);
    }
}

/* release-universe ( id -- ) explicit destroy for affine */
static inline void prim_release_universe(void) {
    uint32_t id = (uint32_t)POP();
    if (id > 0 && id <= space_universe_count) {
        if (space_universes[id].discipline == DISC_AFFINE) {
            space_universe_destroy(id);
        }
    }
}

/* universe-push ( value id -- ) */
static inline void prim_universe_push(void) {
    uint32_t id = (uint32_t)POP();
    uint64_t v = POP();
    space_universe_push(id, v);
}

/* universe-pop ( id -- value ) */
static inline void prim_universe_pop(void) {
    uint32_t id = (uint32_t)POP();
    uint64_t v = 0;
    space_universe_pop(id, &v);
    PUSH(v);
}

/*
 * Borrow Primitives - borrow/drop/fetch/store
 */

/* borrow-pointer ( addr src-id -- borrow-idx ) */
static inline void prim_borrow_pointer(void) {
    uint32_t src = (uint32_t)POP();
    uint64_t addr = POP();
    size_t idx = space_borrow_pointer(src, addr);
    PUSH((uint64_t)idx);
}

/* drop-pointer ( borrow-idx -- ) */
static inline void prim_drop_pointer(void) {
    size_t idx = (size_t)POP();
    space_drop_borrow(idx);
}

/* return-pointer ( borrow-idx src-id -- ) return to source stack */
static inline void prim_return_pointer(void) {
    uint32_t src = (uint32_t)POP();
    size_t idx = (size_t)POP();
    if (space_borrow_active(idx)) {
        uint64_t addr = space_borrows[idx].address;
        space_drop_borrow(idx);
        space_universe_push(src, addr);
    }
}

/* fetch-borrowed ( borrow-idx -- value ) */
static inline void prim_fetch_borrowed(void) {
    size_t idx = (size_t)TOP();
    space_stack[space_sp] = space_fetch_borrowed(idx);
}

/* store-borrowed ( value borrow-idx -- ) */
static inline void prim_store_borrowed(void) {
    size_t idx = (size_t)POP();
    uint64_t v = POP();
    space_store_borrowed(idx, v);
}

/* fetch-and-end ( borrow-idx -- value ) fetch then drop borrow */
static inline void prim_fetch_and_end(void) {
    size_t idx = (size_t)TOP();
    space_stack[space_sp] = space_fetch_borrowed(idx);
    space_drop_borrow(idx);
}

/* store-and-end ( value borrow-idx -- ) store then drop borrow */
static inline void prim_store_and_end(void) {
    size_t idx = (size_t)POP();
    uint64_t v = POP();
    space_store_borrowed(idx, v);
    space_drop_borrow(idx);
}

/*
 * Warp Primitives - warp-into/fetch/store/advance/etc
 */

/* warp-into ( pos target-id -- warp-id ) */
static inline void prim_warp_into(void) {
    uint32_t target = (uint32_t)POP();
    uint64_t pos = POP();
    uint32_t id = space_warp_into("anon", target, pos, 0);
    PUSH(id);
}

/* warp-into-readonly ( pos target-id -- warp-id ) */
static inline void prim_warp_into_readonly(void) {
    uint32_t target = (uint32_t)POP();
    uint64_t pos = POP();
    uint32_t id = space_warp_into("anon", target, pos, 1);
    PUSH(id);
}

/* end-warp ( warp-id -- ) */
static inline void prim_end_warp(void) {
    uint32_t id = (uint32_t)POP();
    space_end_warp(id);
}

/* warp-fetch ( warp-id -- value ) */
static inline void prim_warp_fetch(void) {
    uint32_t id = (uint32_t)TOP();
    space_stack[space_sp] = space_warp_fetch(id);
}

/* warp-store ( value warp-id -- ) */
static inline void prim_warp_store(void) {
    uint32_t id = (uint32_t)POP();
    uint64_t v = POP();
    space_warp_store(id, v);
}

/* warp-advance ( offset warp-id -- ) */
static inline void prim_warp_advance(void) {
    uint32_t id = (uint32_t)POP();
    uint64_t offset = POP();
    space_warp_advance(id, offset);
}

/* warp-position ( warp-id -- pos ) */
static inline void prim_warp_pos(void) {
    uint32_t id = (uint32_t)TOP();
    space_stack[space_sp] = space_warp_position(id);
}

/* warp-save ( warp-id -- ) save current position */
static inline void prim_warp_save(void) {
    uint32_t id = (uint32_t)POP();
    space_warp_save(id);
}

/* warp-restore ( pos warp-id -- success ) */
static inline void prim_warp_restore(void) {
    uint32_t id = (uint32_t)POP();
    uint64_t pos = POP();
    PUSH(space_warp_restore(id, pos) ? 1 : 0);
}

/* warp-null? ( warp-id -- bool ) */
static inline void prim_warp_null(void) {
    uint32_t id = (uint32_t)TOP();
    space_stack[space_sp] = space_warp_is_null(id) ? 1 : 0;
}

/*
 * Text Primitives - mirrors Space.Text.Ops
 */

/* create-text ( ptr len -- handle ) */
static inline void prim_create_text(void) {
    size_t len = (size_t)POP();
    uint8_t *ptr = (uint8_t*)(uintptr_t)POP();
    size_t h = space_create_text(ptr, len);
    PUSH(h);
}

/* text-byte-length ( handle -- len ) */
static inline void prim_text_byte_length(void) {
    size_t h = (size_t)TOP();
    space_stack[space_sp] = space_text_byte_length(h);
}

/* text-grapheme-count ( handle -- count ) */
static inline void prim_text_grapheme_count(void) {
    size_t h = (size_t)TOP();
    space_stack[space_sp] = space_text_grapheme_count(h);
}

/* text-equal ( h1 h2 -- bool ) */
static inline void prim_text_equal(void) {
    size_t h2 = (size_t)POP();
    size_t h1 = (size_t)TOP();
    space_text *t1 = &space_texts[h1];
    space_text *t2 = &space_texts[h2];
    int eq = (t1->byte_len == t2->byte_len) &&
             (memcmp(t1->data, t2->data, t1->byte_len) == 0);
    space_stack[space_sp] = eq ? 1 : 0;
}

/* text-concat ( h1 h2 -- h3 ) */
static inline void prim_text_concat(void) {
    size_t h2 = (size_t)POP();
    size_t h1 = (size_t)POP();
    space_text *t1 = &space_texts[h1];
    space_text *t2 = &space_texts[h2];
    size_t new_len = t1->byte_len + t2->byte_len;
    uint8_t *data = (uint8_t*)space_alloc(new_len);
    memcpy(data, t1->data, t1->byte_len);
    memcpy(data + t1->byte_len, t2->data, t2->byte_len);
    size_t h3 = space_text_count++;
    space_texts[h3].data = data;
    space_texts[h3].byte_len = new_len;
    space_texts[h3].grapheme_count = t1->grapheme_count + t2->grapheme_count;
    PUSH(h3);
}

/*
 * Text Case Primitives - mirrors Space.Text.Case
 * Uses UCD tables from space_ucd_full.h
 */

/* text-to-upper ( handle -- new-handle ) */
static inline void prim_text_to_upper(void) {
    size_t h = (size_t)TOP();
    space_text *t = &space_texts[h];
    uint8_t *out = (uint8_t*)space_alloc(t->byte_len * 3);  /* Worst case expansion */
    size_t out_len = 0;
    size_t i = 0;
    while (i < t->byte_len) {
        uint32_t cp;
        int len = utf8_decode(&t->data[i], &cp);
        cp = ucd_to_upper(cp);
        out_len += utf8_encode(cp, &out[out_len]);
        i += len;
    }
    size_t new_h = space_text_count++;
    space_texts[new_h].data = out;
    space_texts[new_h].byte_len = out_len;
    space_texts[new_h].grapheme_count = t->grapheme_count;
    space_stack[space_sp] = new_h;
}

/* text-to-lower ( handle -- new-handle ) */
static inline void prim_text_to_lower(void) {
    size_t h = (size_t)TOP();
    space_text *t = &space_texts[h];
    uint8_t *out = (uint8_t*)space_alloc(t->byte_len * 3);
    size_t out_len = 0;
    size_t i = 0;
    while (i < t->byte_len) {
        uint32_t cp;
        int len = utf8_decode(&t->data[i], &cp);
        cp = ucd_to_lower(cp);
        out_len += utf8_encode(cp, &out[out_len]);
        i += len;
    }
    size_t new_h = space_text_count++;
    space_texts[new_h].data = out;
    space_texts[new_h].byte_len = out_len;
    space_texts[new_h].grapheme_count = t->grapheme_count;
    space_stack[space_sp] = new_h;
}

/*
 * Normalization Primitives - mirrors Space.Text.Normalize
 * Uses NFD/NFC from space_ucd_full.h
 */

/* text-normalize-nfd ( handle -- new-handle ) */
static inline void prim_text_normalize_nfd(void) {
    size_t h = (size_t)TOP();
    space_text *t = &space_texts[h];

    /* Decode to codepoints */
    uint32_t cps[1024];
    size_t cp_count = 0;
    size_t i = 0;
    while (i < t->byte_len && cp_count < 1024) {
        uint32_t cp;
        int len = utf8_decode(&t->data[i], &cp);
        cps[cp_count++] = cp;
        i += len;
    }

    /* Apply NFD */
    uint32_t nfd_cps[2048];
    size_t nfd_len = ucd_nfd(cps, cp_count, nfd_cps, 2048);

    /* Encode back to UTF-8 */
    uint8_t *out = (uint8_t*)space_alloc(nfd_len * 4);
    size_t out_len = 0;
    for (size_t j = 0; j < nfd_len; j++) {
        out_len += utf8_encode(nfd_cps[j], &out[out_len]);
    }

    size_t new_h = space_text_count++;
    space_texts[new_h].data = out;
    space_texts[new_h].byte_len = out_len;
    space_texts[new_h].grapheme_count = t->grapheme_count;
    space_stack[space_sp] = new_h;
}

/* text-normalize-nfc ( handle -- new-handle ) */
static inline void prim_text_normalize_nfc(void) {
    size_t h = (size_t)TOP();
    space_text *t = &space_texts[h];

    uint32_t cps[1024];
    size_t cp_count = 0;
    size_t i = 0;
    while (i < t->byte_len && cp_count < 1024) {
        uint32_t cp;
        int len = utf8_decode(&t->data[i], &cp);
        cps[cp_count++] = cp;
        i += len;
    }

    uint32_t nfc_cps[2048];
    size_t nfc_len = ucd_nfc(cps, cp_count, nfc_cps, 2048);

    uint8_t *out = (uint8_t*)space_alloc(nfc_len * 4);
    size_t out_len = 0;
    for (size_t j = 0; j < nfc_len; j++) {
        out_len += utf8_encode(nfc_cps[j], &out[out_len]);
    }

    size_t new_h = space_text_count++;
    space_texts[new_h].data = out;
    space_texts[new_h].byte_len = out_len;
    space_texts[new_h].grapheme_count = t->grapheme_count;
    space_stack[space_sp] = new_h;
}

#endif /* SPACE_RUNTIME_H */
