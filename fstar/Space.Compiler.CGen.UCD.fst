module Space.Compiler.CGen.UCD

(** Generate C UCD tables from F* data structures
    Type-safe, verified generation - no shell scripts *)

open FStar.String
open FStar.List.Tot
open FStar.Char
open Space.Text.UCD.Types
open Space.Text.UCD.Case
open Space.Text.UCD.CCC
open Space.Text.UCD.Decomp
open Space.Text.UCD.Comp

(** Hex digit *)
let hex_digit (n: nat{n < 16}) : string =
  if n < 10 then make 1 (char_of_int (48 + n))
  else make 1 (char_of_int (55 + n))

(** Convert nat to hex string (4 digits minimum) *)
let rec hex_digits (n: nat) (acc: string) : Tot string (decreases n) =
  if n = 0 then (if strlen acc = 0 then "0" else acc)
  else hex_digits (n / 16) (hex_digit (n % 16) ^ acc)

let to_hex (n: nat) : string =
  let h = hex_digits n "" in
  let pad = if strlen h < 4 then make (4 - strlen h) (char_of_int 48) else "" in
  "0x" ^ pad ^ h

(** Generate single mapping entry *)
let gen_mapping (e: mapping_entry) : string =
  "    {" ^ to_hex e.codepoint ^ ", " ^ to_hex e.mapped ^ "},"

(** Generate CCC entry *)
let gen_ccc (e: ccc_entry) : string =
  "    {" ^ to_hex e.codepoint ^ ", " ^ string_of_int e.ccc ^ "},"

(** Generate decomposition entry *)
let gen_decomp (e: decomp_entry) : string =
  let len = length e.decomposition in
  let d0 = if len > 0 then to_hex (index e.decomposition 0) else "0" in
  let d1 = if len > 1 then to_hex (index e.decomposition 1) else "0" in
  let d2 = if len > 2 then to_hex (index e.decomposition 2) else "0" in
  let d3 = if len > 3 then to_hex (index e.decomposition 3) else "0" in
  "    {" ^ to_hex e.codepoint ^ ", {" ^ d0 ^ ", " ^ d1 ^ ", " ^ d2 ^ ", " ^ d3 ^ "}, " ^ string_of_int len ^ "},"

(** Generate composition entry *)
let gen_comp (e: comp_entry) : string =
  "    {" ^ to_hex e.first ^ ", " ^ to_hex e.second ^ ", " ^ to_hex e.composed ^ "},"

(** Join lines with newlines *)
let rec join_lines (lines: list string) : Tot string (decreases lines) =
  match lines with
  | [] -> ""
  | [x] -> x
  | x :: rest -> x ^ "\n" ^ join_lines rest

(** Generate mapping table *)
let gen_mapping_table (name: string) (entries: list mapping_entry) : string =
  "static const ucd_mapping " ^ name ^ "[] = {\n" ^
  join_lines (map gen_mapping entries) ^ "\n" ^
  "    {0, 0}  /* sentinel */\n" ^
  "};\n" ^
  "#define " ^ String.uppercase name ^ "_COUNT (sizeof(" ^ name ^ ")/sizeof(" ^ name ^ "[0])-1)"

(** Generate CCC table *)
let gen_ccc_table (entries: list ccc_entry) : string =
  "static const ucd_ccc ucd_ccc_table[] = {\n" ^
  join_lines (map gen_ccc entries) ^ "\n" ^
  "    {0, 0}  /* sentinel */\n" ^
  "};\n" ^
  "#define UCD_CCC_COUNT (sizeof(ucd_ccc_table)/sizeof(ucd_ccc_table[0])-1)"

(** Generate decomposition table *)
let gen_decomp_table (entries: list decomp_entry) : string =
  "static const ucd_decomp ucd_decomp_table[] = {\n" ^
  join_lines (map gen_decomp entries) ^ "\n" ^
  "    {0, {0,0,0,0}, 0}  /* sentinel */\n" ^
  "};\n" ^
  "#define UCD_DECOMP_COUNT (sizeof(ucd_decomp_table)/sizeof(ucd_decomp_table[0])-1)"

(** Generate composition table *)
let gen_comp_table (entries: list comp_entry) : string =
  "static const ucd_comp ucd_comp_table[] = {\n" ^
  join_lines (map gen_comp entries) ^ "\n" ^
  "    {0, 0, 0}  /* sentinel */\n" ^
  "};\n" ^
  "#define UCD_COMP_COUNT (sizeof(ucd_comp_table)/sizeof(ucd_comp_table[0])-1)"

(** C header preamble *)
let header_preamble : string =
"/* Space Language - Complete Unicode Character Database
 * Generated from Space.Text.UCD.* F* modules
 * Unicode Version: 15.0.0
 *
 * This file is AUTO-GENERATED by Space.Compiler.CGen.UCD
 * Do not edit manually.
 */

#ifndef SPACE_UCD_FULL_H
#define SPACE_UCD_FULL_H

#include <stdint.h>
#include <stddef.h>

/* Simple mapping: codepoint -> codepoint */
typedef struct { uint32_t from, to; } ucd_mapping;

/* Combining class: codepoint -> class (0-255) */
typedef struct { uint32_t cp; uint8_t ccc; } ucd_ccc;

/* Decomposition: codepoint -> up to 4 codepoints */
typedef struct { uint32_t cp; uint32_t decomp[4]; uint8_t len; } ucd_decomp;

/* Composition: (first, second) -> result */
typedef struct { uint32_t first, second, result; } ucd_comp;

/*===========================================================================
 * UPPERCASE MAPPINGS
 *===========================================================================*/
"

(** C lookup functions *)
let lookup_functions : string =
"
/*===========================================================================
 * LOOKUP FUNCTIONS
 *===========================================================================*/

/* Binary search for mappings (tables are sorted by codepoint) */
static inline uint32_t ucd_lookup_mapping(const ucd_mapping *table, size_t count, uint32_t cp) {
    size_t lo = 0, hi = count;
    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;
        if (table[mid].from < cp) lo = mid + 1;
        else if (table[mid].from > cp) hi = mid;
        else return table[mid].to;
    }
    return cp;  /* not found, return unchanged */
}

static inline uint32_t ucd_to_upper(uint32_t cp) {
    if (cp >= 'a' && cp <= 'z') return cp - 32;  /* fast path */
    return ucd_lookup_mapping(ucd_uppercase, UCD_UPPERCASE_COUNT, cp);
}

static inline uint32_t ucd_to_lower(uint32_t cp) {
    if (cp >= 'A' && cp <= 'Z') return cp + 32;  /* fast path */
    return ucd_lookup_mapping(ucd_lowercase, UCD_LOWERCASE_COUNT, cp);
}

static inline uint8_t ucd_get_ccc(uint32_t cp) {
    size_t lo = 0, hi = UCD_CCC_COUNT;
    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;
        if (ucd_ccc_table[mid].cp < cp) lo = mid + 1;
        else if (ucd_ccc_table[mid].cp > cp) hi = mid;
        else return ucd_ccc_table[mid].ccc;
    }
    return 0;
}

static inline const ucd_decomp* ucd_get_decomp(uint32_t cp) {
    size_t lo = 0, hi = UCD_DECOMP_COUNT;
    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;
        if (ucd_decomp_table[mid].cp < cp) lo = mid + 1;
        else if (ucd_decomp_table[mid].cp > cp) hi = mid;
        else return &ucd_decomp_table[mid];
    }
    return NULL;
}

static inline uint32_t ucd_compose(uint32_t first, uint32_t second) {
    for (size_t i = 0; i < UCD_COMP_COUNT; i++) {
        if (ucd_comp_table[i].first == first && ucd_comp_table[i].second == second)
            return ucd_comp_table[i].result;
        if (ucd_comp_table[i].first > first) break;
    }
    return 0;  /* no composition */
}

/*===========================================================================
 * UTF-8 ENCODING/DECODING
 *===========================================================================*/

static inline int utf8_encode(uint32_t cp, uint8_t *out) {
    if (cp < 0x80) {
        out[0] = cp;
        return 1;
    } else if (cp < 0x800) {
        out[0] = 0xC0 | (cp >> 6);
        out[1] = 0x80 | (cp & 0x3F);
        return 2;
    } else if (cp < 0x10000) {
        out[0] = 0xE0 | (cp >> 12);
        out[1] = 0x80 | ((cp >> 6) & 0x3F);
        out[2] = 0x80 | (cp & 0x3F);
        return 3;
    } else {
        out[0] = 0xF0 | (cp >> 18);
        out[1] = 0x80 | ((cp >> 12) & 0x3F);
        out[2] = 0x80 | ((cp >> 6) & 0x3F);
        out[3] = 0x80 | (cp & 0x3F);
        return 4;
    }
}

static inline int utf8_decode(const uint8_t *in, uint32_t *cp) {
    if (in[0] < 0x80) {
        *cp = in[0];
        return 1;
    } else if ((in[0] & 0xE0) == 0xC0) {
        *cp = ((in[0] & 0x1F) << 6) | (in[1] & 0x3F);
        return 2;
    } else if ((in[0] & 0xF0) == 0xE0) {
        *cp = ((in[0] & 0x0F) << 12) | ((in[1] & 0x3F) << 6) | (in[2] & 0x3F);
        return 3;
    } else {
        *cp = ((in[0] & 0x07) << 18) | ((in[1] & 0x3F) << 12) |
              ((in[2] & 0x3F) << 6) | (in[3] & 0x3F);
        return 4;
    }
}

/*===========================================================================
 * NORMALIZATION (NFD/NFC)
 *===========================================================================*/

/* Canonical ordering: sort combining marks by CCC */
static inline void ucd_canonical_order(uint32_t *cps, size_t len) {
    for (size_t i = 1; i < len; i++) {
        uint8_t ccc_i = ucd_get_ccc(cps[i]);
        if (ccc_i == 0) continue;
        size_t j = i;
        while (j > 0 && ucd_get_ccc(cps[j-1]) > ccc_i) {
            uint32_t tmp = cps[j]; cps[j] = cps[j-1]; cps[j-1] = tmp;
            j--;
        }
    }
}

/* NFD: Canonical decomposition */
static inline size_t ucd_nfd(const uint32_t *in, size_t in_len, uint32_t *out, size_t out_max) {
    size_t out_len = 0;
    for (size_t i = 0; i < in_len && out_len < out_max; i++) {
        const ucd_decomp *d = ucd_get_decomp(in[i]);
        if (d) {
            for (int j = 0; j < d->len && out_len < out_max; j++)
                out[out_len++] = d->decomp[j];
        } else {
            out[out_len++] = in[i];
        }
    }
    ucd_canonical_order(out, out_len);
    return out_len;
}

/* NFC: Canonical decomposition + composition */
static inline size_t ucd_nfc(const uint32_t *in, size_t in_len, uint32_t *out, size_t out_max) {
    /* First decompose */
    size_t len = ucd_nfd(in, in_len, out, out_max);

    /* Then compose */
    size_t last_starter = 0;
    for (size_t i = 1; i < len; i++) {
        uint8_t ccc = ucd_get_ccc(out[i]);
        uint32_t composed = ucd_compose(out[last_starter], out[i]);
        if (composed && (ccc == 0 || (i > 0 && ucd_get_ccc(out[i-1]) < ccc))) {
            out[last_starter] = composed;
            /* Remove composed character by shifting */
            for (size_t j = i; j < len - 1; j++) out[j] = out[j+1];
            len--;
            i--;
        } else if (ccc == 0) {
            last_starter = i;
        }
    }
    return len;
}

#endif /* SPACE_UCD_FULL_H */
"

(** Generate the complete UCD header *)
let gen_ucd_header : string =
  header_preamble ^
  gen_mapping_table "ucd_uppercase" uppercase_mappings ^ "\n\n" ^
  "/*===========================================================================\n" ^
  " * LOWERCASE MAPPINGS\n" ^
  " *===========================================================================*/\n\n" ^
  gen_mapping_table "ucd_lowercase" lowercase_mappings ^ "\n\n" ^
  "/*===========================================================================\n" ^
  " * COMBINING CHARACTER CLASSES\n" ^
  " *===========================================================================*/\n\n" ^
  gen_ccc_table combining_class_table ^ "\n\n" ^
  "/*===========================================================================\n" ^
  " * CANONICAL DECOMPOSITIONS\n" ^
  " *===========================================================================*/\n\n" ^
  gen_decomp_table canonical_decomposition_table ^ "\n\n" ^
  "/*===========================================================================\n" ^
  " * COMPOSITION PAIRS\n" ^
  " *===========================================================================*/\n\n" ^
  gen_comp_table composition_pair_table ^
  lookup_functions
